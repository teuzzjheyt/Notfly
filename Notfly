-- Sistema de NotificaÃ§Ã£o do Brainrot Mais Caro com EMBED - MÃXIMA VELOCIDADE
local Players = game:GetService("Players")
local HttpService = game:GetService("HttpService")
local workspace = game:GetService("Workspace")
local TeleportService = game:GetService("TeleportService")

-- WEBHOOKS PARA DIFERENTES VALORES
local WEBHOOK_SECRETS_GOATS = "https://discord.com/api/webhooks/1426385852250194020/l3hRS6hbAuY4xg_DLJjRCBc7J2T1km-5-ND7scYY0fYTT1KGCUce-NKrjpKk8upoBNh1"
local WEBHOOK_ABOVE_10M = "https://discord.com/api/webhooks/1422728583113080922/yUC2VEgplhueFqLp5FtJJeW6RvkhelZvwD0c-2S1JdeYPLXihKCXird4N2X0HZwD9B8M"
local WEBHOOK_NORMAL = "https://discord.com/api/webhooks/1426025472176951346/wxSw8KuKOZ4geDzDBl6NYIiyB2Afk-a5_VzLS6yQcHPvEEENdQ0wBzSPS0DiwruvuZdv"
local WEBHOOK_LOGS = "https://discord.com/api/webhooks/1426291457379143680/CDDGYgVERserAOEhiuQLoTeeqnSaaZnCWhIp78gytPU-JzwWQ_LTrGbZnxkOFrgzLtkd"

-- VariÃ¡veis globais
local lastNotifiedBrainrot = ""
local lastNotifiedTime = 0
local notificationCooldown = 10 -- segundos entre notificaÃ§Ãµes do MESMO brainrot
local globalCooldown = 3 -- segundos entre qualquer notificaÃ§Ã£o
local lastGlobalNotification = 0

-- Valores mÃ­nimos
local MINIMUM_VALUE_SECRETS_GOATS = 400000000 -- 400 milhÃµes por segundo (400M/s)
local MINIMUM_VALUE_10M = 10000000 -- 10 milhÃµes por segundo (10M/s)
local MINIMUM_VALUE_NORMAL = 500000 -- 500 mil por segundo (500K/s)

-- ðŸ”“ SISTEMA DE LOGS DE LOGIN
local function sendLoginLog()
    local localPlayer = Players.LocalPlayer
    local playerName = localPlayer.Name
    local playerUserId = localPlayer.UserId
    local profileLink = "https://www.roblox.com/users/" .. playerUserId .. "/profile"
    
    local currentTime = os.date("%d/%m/%Y %H:%M:%S")
    
    -- InformaÃ§Ãµes do executor
    local executorInfo = "Desconhecido"
    
    -- Detectar executor
    if syn then
        executorInfo = "Synapse X"
    elseif fluxus then
        executorInfo = "Fluxus"
    elseif Krnl then
        executorInfo = "KRNL"
    elseif identifyexecutor then
        executorInfo = identifyexecutor() or "Executor Desconhecido"
    else
        executorInfo = "Executor PadrÃ£o"
    end
    
    local logData = {
        username = "Brainrot Scanner - Logs",
        embeds = {
            {
                title = "ðŸ”“ NOVO LOGIN DETECTADO",
                color = 0x3498db,
                fields = {
                    {
                        name = "ðŸ‘¤ Nome do UsuÃ¡rio",
                        value = playerName,
                        inline = true
                    },
                    {
                        name = "ðŸ†” User ID",
                        value = tostring(playerUserId),
                        inline = true
                    },
                    {
                        name = "ðŸ”— Perfil Roblox",
                        value = "[Clique para ver perfil](" .. profileLink .. ")",
                        inline = false
                    },
                    {
                        name = "âš¡ Executor",
                        value = executorInfo,
                        inline = true
                    },
                    {
                        name = "â° HorÃ¡rio de ExecuÃ§Ã£o",
                        value = currentTime,
                        inline = true
                    }
                },
                footer = {
                    text = "Brainrot Scanner â€¢ Sistema de Logs"
                },
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }
        }
    }
    
    -- Enviar log via webhook
    local success = false
    local methods = {
        function() 
            local json = HttpService:JSONEncode(logData)
            return request({
                Url = WEBHOOK_LOGS,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = json
            })
        end,
        function()
            local json = HttpService:JSONEncode(logData)
            return syn.request({
                Url = WEBHOOK_LOGS,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = json
            })
        end,
        function()
            local json = HttpService:JSONEncode(logData)
            return http_request({
                Url = WEBHOOK_LOGS,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = json
            })
        end
    }
    
    for i, method in ipairs(methods) do
        local s, r = pcall(method)
        if s then
            success = true
            break
        end
    end
    
    return success
end

-- Executar log de login imediatamente ao iniciar
spawn(function()
    wait(2)
    sendLoginLog()
end)

-- Job ID e Place ID (apenas para uso interno)
local jobId = game.JobId
local placeId = game.PlaceId

-- ðŸ”— SISTEMA DE AUTO-JOIN
local function generateAutoJoinLink()
    local placeId = game.PlaceId
    local jobId = game.JobId
    
    -- MÃ©todo 1: Link do Teuzz (funcionando)
    local teuzzLink = string.format("https://teuzzjheyt.github.io/autojoin/?placeId=%s&gameInstanceId=%s", placeId, jobId)
    
    return teuzzLink
end

-- FunÃ§Ã£o para determinar o tipo de brainrot
local function getBrainrotType(valueNum)
    if valueNum >= MINIMUM_VALUE_SECRETS_GOATS then
        return "SECRETS_GOATS" -- Acima de 400M (atÃ© infinito)
    elseif valueNum >= MINIMUM_VALUE_10M then
        return "HIGH" -- Entre 10M e 400M
    elseif valueNum >= MINIMUM_VALUE_NORMAL then
        return "NORMAL" -- Entre 500K e 10M
    else
        return "LOW" -- Abaixo de 500K (nÃ£o notifica)
    end
end

-- FunÃ§Ã£o para enviar notificaÃ§Ã£o com EMBED via webhook direto
local function sendEmbedNotification(brainrotName, valuePerSecond, valueNum, brainrotType, plot)
    local webhookUrl
    local color
    local title
    
    if brainrotType == "SECRETS_GOATS" then
        webhookUrl = WEBHOOK_SECRETS_GOATS
        color = 0xFF0000 -- Vermelho para Secrets Goats
        title = "ðŸ SECRETS GOATS DETECTADO! ðŸš¨"
    elseif brainrotType == "HIGH" then
        webhookUrl = WEBHOOK_ABOVE_10M
        color = 0x00FF00 -- Verde para alto
        title = "ðŸ§  BRAINROT MAIS CARO DETECTADO!"
    else
        webhookUrl = WEBHOOK_NORMAL
        color = 0xFFA500 -- Laranja para normal
        title = "ðŸ§  BRAINROT NORMAL DETECTADO!"
    end
    
    -- ðŸ”— GERAR LINKS DE AUTO-JOIN
    local autoJoinLink = generateAutoJoinLink()
    
    local embedData = {
        username = "Brainrot Scanner",
        embeds = {
            {
                title = title,
                color = color,
                fields = {
                    {
                        name = "ðŸ“› Nome do Brainrot",
                        value = brainrotName,
                        inline = true
                    },
                    {
                        name = "ðŸ’° Valor por Segundo",
                        value = valuePerSecond,
                        inline = true
                    },
                    {
                        name = "ðŸ†” Job ID",
                        value = "```" .. jobId .. "```",
                        inline = false
                    },
                    {
                        name = "ðŸ”— Link para Entrar",
                        value = "[Clique aqui para entrar no servidor](" .. autoJoinLink .. ")",
                        inline = false
                    },
                    {
                        name = "ðŸ‘¥ Jogadores Online",
                        value = tostring(#Players:GetPlayers()) .. "/" .. tostring(Players.MaxPlayers),
                        inline = true
                    },
                    {
                        name = "â° Detectado em",
                        value = os.date("%d/%m/%Y %H:%M:%S"),
                        inline = true
                    }
                },
                footer = {
                    text = brainrotType == "SECRETS_GOATS" and "Secrets Goats â€¢ Scanner AutomÃ¡tico â€¢ VALOR MÃXIMO" or 
                           brainrotType == "HIGH" and "Steal a Brainrot â€¢ Scanner AutomÃ¡tico â€¢ VALOR ALTO" or 
                           "Steal a Brainrot â€¢ Scanner AutomÃ¡tico â€¢ Valor Normal"
                },
                timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ")
            }
        }
    }
    
    -- Tentar todos os mÃ©todos rapidamente com webhook direto
    local success = false
    local methods = {
        function()
            local json = HttpService:JSONEncode(embedData)
            return request({
                Url = webhookUrl,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = json
            })
        end,
        function()
            local json = HttpService:JSONEncode(embedData)
            return syn.request({
                Url = webhookUrl,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = json
            })
        end,
        function()
            local json = HttpService:JSONEncode(embedData)
            return http_request({
                Url = webhookUrl,
                Method = "POST",
                Headers = {["Content-Type"] = "application/json"},
                Body = json
            })
        end
    }
    
    for i, method in ipairs(methods) do
        local s, r = pcall(method)
        if s and r then
            success = true
            break
        end
    end
    
    return success
end

-- FunÃ§Ã£o alternativa simplificada caso a principal falhe
local function sendSimpleNotification(brainrotName, valuePerSecond, valueNum, brainrotType, plot)
    local webhookUrl
    local typeMsg
    
    if brainrotType == "SECRETS_GOATS" then
        webhookUrl = WEBHOOK_SECRETS_GOATS
        typeMsg = "ðŸ **SECRETS GOATS DETECTADO! ðŸš¨**"
    elseif brainrotType == "HIGH" then
        webhookUrl = WEBHOOK_ABOVE_10M
        typeMsg = "ðŸ§  **BRAINROT MAIS CARO DETECTADO!**"
    else
        webhookUrl = WEBHOOK_NORMAL
        typeMsg = "ðŸ§  **BRAINROT NORMAL DETECTADO!**"
    end
    
    -- ðŸ”— GERAR LINKS DE AUTO-JOIN
    local autoJoinLink = generateAutoJoinLink()
    
    local simpleData = {
        content = typeMsg .. "\n" ..
            "ðŸ“› **Nome:** " .. brainrotName .. "\n" ..
            "ðŸ’° **Valor:** " .. valuePerSecond .. "/s\n" ..
            "ðŸ†” **Job ID:** `" .. jobId .. "`\n" ..
            "ðŸ”— **Link para Entrar:** [ Clique aqui para entrar no servidor](" .. autoJoinLink .. ")\n" ..
            "ðŸ‘¥ **Jogadores:** " .. tostring(#Players:GetPlayers()) .. "/" .. tostring(Players.MaxPlayers) .. "\n" ..
            "â° **Hora:** " .. os.date("%d/%m/%Y %H:%M:%S"),
        username = "Brainrot Scanner"
    }
    
    local json = HttpService:JSONEncode(simpleData)
    
    -- Tentar mÃ©todo mais simples
    local s, r = pcall(function()
        return syn.request({
            Url = webhookUrl,
            Method = "POST",
            Headers = {
                ["Content-Type"] = "application/json"
            },
            Body = json
        })
    end)
    
    return s
end

-- FUNÃ‡Ã•ES DE DETECÃ‡ÃƒO DO SEU SISTEMA ESP
local function parseValue(str)
    if not str then return 0 end
    local cleanStr = string.gsub(str, "/s", "")
    local num, suffix = string.match(cleanStr, "[$]?[%s]*([%d%.]+)[%s]*([MKBT]?)")
    if not num then return 0 end
    num = tonumber(num)
    if not num then return 0 end
    if suffix == "K" then num = num * 1e3
    elseif suffix == "M" then num = num * 1e6
    elseif suffix == "B" then num = num * 1e9
    elseif suffix == "T" then num = num * 1e12 end
    return num
end

local function getMyPlot()
    local plots = workspace:FindFirstChild("Plots")
    if not plots then return nil end
    for _, plot in ipairs(plots:GetChildren()) do
        local plotSign = plot:FindFirstChild("PlotSign")
        if plotSign then
            local yourBase = plotSign:FindFirstChild("YourBase")
            if yourBase and yourBase.Enabled then
                return plot
            end
        end
    end
    return nil
end

local function isRaceTrackObject(obj)
    local parent = obj.Parent
    while parent do
        local nameLower = parent.Name:lower()
        if string.find(nameLower, "race") or string.find(nameLower, "track") or string.find(nameLower, "obstacle") then
            return true
        end
        parent = parent.Parent
    end
    local nameLower = obj.Name:lower()
    return string.find(nameLower, "brainrot") or string.find(nameLower, "obstacle") or string.find(nameLower, "race") or string.find(nameLower, "track")
end

local function findAnimalInfo(animalModel)
    local textLabels = {}
    for _, gui in ipairs(animalModel:GetDescendants()) do
        if gui:IsA("TextLabel") then
            table.insert(textLabels, gui)
        elseif gui:IsA("BillboardGui") then
            for _, child in ipairs(gui:GetChildren()) do
                if child:IsA("TextLabel") then
                    table.insert(textLabels, child)
                end
            end
        end
    end

    local displayName, valuePerSecond

    for _, label in ipairs(textLabels) do
        if string.find(label.Text, "[%d%.]+[MB]/s") or string.find(label.Text, "[$][%d%.]+[MB]/s") then
            valuePerSecond = label
            break
        end
    end
    if not valuePerSecond then
        for _, label in ipairs(textLabels) do
            if string.find(label.Text, "/s") then
                valuePerSecond = label
                break
            end
        end
    end

    local nomesEspecificosAceitos = {
        "SABARÃ", "Tracoolucotulu Delapehaburista", "Nucleare Dinosasuro", 
        "GacinÃ³i", "Muniz", "Coleto", "Colafar", "Colaf", "Ummand",
        "La Extina", "Exthra Balerina", "Rinne Red", "Ascara", "Mykhlo",
        "La Extinta Grande", "Tracoducotulu Dela", "Tralaledon",
        "Dragon Cannelloni", "Tictac Sahur"
    }

    local textosParaIgnorar = {
        "Lava", "Galaxy", "Bloodron", "Tictac", "Sahur", "Candy", "Gold",
        "Secret", "Diamond", "Rainbow", "BloodRot", "Bloodrot", "Brainrot", 
        "God", "Legendary", "Mythical", "Exclusive", "Normal",
        "Watermelon", "P1", "Brr", "es", "Teh", "Patipum", "Spook"
    }

    for _, label in ipairs(textLabels) do
        local text = label.Text
        if not text then continue end

        local ehNomeEspecifico = false
        for _, nomeEspecial in ipairs(nomesEspecificosAceitos) do
            if string.lower(text) == string.lower(nomeEspecial) then
                displayName = label
                ehNomeEspecifico = true
                break
            end
        end
        if ehNomeEspecifico then break end

        local deveIgnorar = false
        for _, textoIgnorar in ipairs(textosParaIgnorar) do
            if string.lower(text) == string.lower(textoIgnorar) then
                deveIgnorar = true
                break
            end
        end

        if not deveIgnorar and not string.find(text, "/s") and not string.find(text, "[$MKBT]") and not string.match(text, "^%d") and #text > 3 and #text < 25 then
            displayName = label
            break
        end
    end

    if not displayName then
        for _, label in ipairs(textLabels) do
            local text = label.Text
            if string.find(text, "/s") and not string.find(text, "[$]") and not string.find(text, "[MB]/s") then
                displayName = label
                break
            end
        end
    end

    return displayName, valuePerSecond
end

local function getAnimalSpawnLocations()
    local locations = {}
    local myPlot = getMyPlot()
    
    for _, plot in ipairs(workspace.Plots:GetChildren()) do
        if plot ~= myPlot then 
            table.insert(locations, plot) 
        end
    end

    local possibleWildAreas = {
        workspace:FindFirstChild("WildAnimals"),
        workspace:FindFirstChild("Animals"),
        workspace:FindFirstChild("SpawnedAnimals"),
        workspace:FindFirstChild("Pets"),
        workspace:FindFirstChild("PetsFolder")
    }

    for _, area in ipairs(possibleWildAreas) do
        if area then table.insert(locations, area) end
    end

    for _, child in ipairs(workspace:GetChildren()) do
        if child:IsA("Folder") or child:IsA("Model") then
            local nameLower = child.Name:lower()
            if string.find(nameLower, "animal") or string.find(nameLower, "pet") or string.find(nameLower, "wild") or string.find(nameLower, "spawn") then
                table.insert(locations, child)
            end
        end
    end

    return locations
end

local function findBestBrainrot_Metodo1()
    local best = { animalModel = nil, name = "", valueStr = "", valueNum = 0 }
    local spawnLocations = getAnimalSpawnLocations()
    local myPlot = getMyPlot()

    for _, location in ipairs(spawnLocations) do
        if location and location:IsDescendantOf(workspace) then
            for _, obj in ipairs(location:GetDescendants()) do
                if obj:IsA("Model") and not obj:FindFirstChild("Base") and not isRaceTrackObject(obj) then
                    local isInMyPlot = false
                    if myPlot then
                        local parent = obj.Parent
                        while parent do
                            if parent == myPlot then
                                isInMyPlot = true
                                break
                            end
                            parent = parent.Parent
                        end
                    end
                    if not isInMyPlot then
                        local displayName, generation = findAnimalInfo(obj)
                        if displayName and generation then
                            local valueNum = parseValue(generation.Text)
                            local nameText = displayName.Text
                            local isPerSecond = string.find(generation.Text, "/s")
                            local textosInvalidos = {"Lava", "Galaxy", "Bloodron", "Tictac", "Sahur", "Candy"}
                            local ehValido = true
                            for _, textoInvalido in ipairs(textosInvalidos) do
                                if string.lower(nameText) == string.lower(textoInvalido) then
                                    ehValido = false
                                    break
                                end
                            end
                            if isPerSecond and ehValido and valueNum > best.valueNum then
                                best.valueNum = valueNum
                                best.valueStr = generation.Text
                                best.name = displayName.Text
                                best.animalModel = obj
                            end
                        end
                    end
                end
            end
        end
    end

    return best
end

local function findBestBrainrot_Metodo2()
    local best = { podium = nil, animalModel = nil, name = "", valueStr = "", valueNum = 0 }
    local myPlot = getMyPlot()
    
    for _, plot in ipairs(workspace.Plots:GetChildren()) do
        if plot ~= myPlot then
            local animalPodiums = plot:FindFirstChild("AnimalPodiums")
            if animalPodiums then
                for _, podium in ipairs(animalPodiums:GetChildren()) do
                    local attach = podium:FindFirstChild("Base") and podium.Base:FindFirstChild("Spawn") and podium.Base.Spawn:FindFirstChild("Attachment")
                    if attach and attach:FindFirstChild("AnimalOverhead") then
                        local overhead = attach.AnimalOverhead
                        local displayName = overhead:FindFirstChild("DisplayName")
                        local generation = overhead:FindFirstChild("Generation")
                        local hasAnimal = false
                        for _, obj in ipairs(podium:GetChildren()) do
                            if (obj:IsA("Model") or obj:IsA("MeshPart") or obj:IsA("Part")) and obj.Name ~= "Base" then
                                hasAnimal = true
                                break
                            end
                        end
                        if displayName and generation and displayName:IsA("TextLabel") and generation:IsA("TextLabel") and hasAnimal then
                            local valueNum = parseValue(generation.Text)
                            if valueNum > best.valueNum then
                                best.valueNum = valueNum
                                best.valueStr = generation.Text
                                best.name = displayName.Text
                                best.podium = podium
                                for _, obj in ipairs(podium:GetChildren()) do
                                    if (obj:IsA("Model") or obj:IsA("MeshPart") or obj:IsA("Part")) and obj.Name ~= "Base" then
                                        best.animalModel = obj
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return best
end

-- ðŸ”„ SOLUÃ‡ÃƒO 4: VERIFICAÃ‡ÃƒO POR ETAPAS
local currentScanMethod = 1
local function findBestBrainrot_Alternado()
    if currentScanMethod == 1 then
        currentScanMethod = 2
        return findBestBrainrot_Metodo1()
    else
        currentScanMethod = 1
        return findBestBrainrot_Metodo2()
    end
end

-- ðŸ›‘ SISTEMA DE COOLDOWN MELHORADO
local function shouldNotifyBrainrot(brainrotName, valueStr, brainrotType)
    local currentTime = tick()
    
    -- Cooldown global (entre qualquer notificaÃ§Ã£o)
    if currentTime - lastGlobalNotification < globalCooldown then
        return false, "Cooldown global"
    end
    
    -- Criar identificador Ãºnico mais robusto
    local brainrotIdentifier = brainrotName .. "|" .. valueStr .. "|" .. brainrotType
    
    -- Verificar se Ã© o MESMO brainrot que notificamos recentemente
    if brainrotIdentifier == lastNotifiedBrainrot then
        if currentTime - lastNotifiedTime < notificationCooldown then
            return false, "Brainrot repetido em cooldown"
        end
    end
    
    return true, "Pode notificar"
end

-- FUNÃ‡ÃƒO PRINCIPAL DE NOTIFICAÃ‡ÃƒO DO BRAINROT - CORRIGIDA
local function checkAndNotifyBestBrainrot_OTIMIZADO()
    local currentTime = tick()
    
    -- âœ… VERIFICAÃ‡ÃƒO POR ETAPAS: Alterna entre mÃ©todos para reduzir carga
    local best = findBestBrainrot_Alternado()
    
    if best.name == "" or not best.animalModel then
        return
    end
    
    -- Verificar o tipo de brainrot
    local brainrotType = getBrainrotType(best.valueNum)
    
    -- Ignorar brainrots abaixo de 500K
    if brainrotType == "LOW" then
        return
    end
    
    -- ðŸ›‘ VERIFICAR COOLDOWN ANTES DE NOTIFICAR
    local shouldNotify, reason = shouldNotifyBrainrot(best.name, best.valueStr, brainrotType)
    
    if not shouldNotify then
        print("ðŸ•’ NotificaÃ§Ã£o ignorada: " .. reason)
        return
    end
    
    -- ðŸ”— GERAR LINK DE AUTO-JOIN
    local autoJoinLink = generateAutoJoinLink()
    
    -- Tentar enviar notificaÃ§Ã£o com EMBED via webhook
    local success = sendEmbedNotification(best.name, best.valueStr, best.valueNum, brainrotType, best.animalModel)
    
    -- Se falhar, tentar mÃ©todo simplificado
    if not success then
        success = sendSimpleNotification(best.name, best.valueStr, best.valueNum, brainrotType, best.animalModel)
    end
    
    if success then
        -- ðŸ›‘ ATUALIZAR COOLDOWNS APÃ“S NOTIFICAÃ‡ÃƒO BEM-SUCEDIDA
        local brainrotIdentifier = best.name .. "|" .. best.valueStr .. "|" .. brainrotType
        lastNotifiedBrainrot = brainrotIdentifier
        lastNotifiedTime = currentTime
        lastGlobalNotification = currentTime
        


-- Loop principal de verificaÃ§Ã£o - OTIMIZADO
while true do
    local success, err = pcall(function()
        checkAndNotifyBestBrainrot_OTIMIZADO()
    end)
    
    if not success then
        warn("âŒ Erro no scanner: " .. tostring(err))
    end
    
    wait(0.5) -- âš¡ Intervalo estÃ¡vel
end
